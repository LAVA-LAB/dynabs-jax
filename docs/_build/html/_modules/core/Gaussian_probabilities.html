

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>core.Gaussian_probabilities &mdash; DynAbs-JAX  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            DynAbs-JAX
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ReadMe.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ReadMe.html#reproducing-experiments">Reproducing experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">DynAbs-JAX contents</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DynAbs-JAX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">core.Gaussian_probabilities</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for core.Gaussian_probabilities</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>


<span class="c1"># Note: The following implementation only works for Gaussian distributions with diagonal covariance</span>

<div class="viewcode-block" id="dynslice">
<a class="viewcode-back" href="../../core.html#core.Gaussian_probabilities.dynslice">[docs]</a>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">dynslice</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">idx_low</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a vector of indices, keep only those starting at position idx_low and of length size.</span>

<span class="sd">    :param V: Vector of indices.</span>
<span class="sd">    :param idx_low: Index to start slice at.</span>
<span class="sd">    :param size: Number of elements to keep in slice.</span>
<span class="sd">    :return: Slice of V.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">roll</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="o">-</span><span class="n">idx_low</span><span class="p">)</span>
    <span class="c1"># roll_zero = roll.at[size:].set(0)</span>
    <span class="k">return</span> <span class="n">roll</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span></div>



<div class="viewcode-block" id="integ_Gauss">
<a class="viewcode-back" href="../../core.html#core.Gaussian_probabilities.integ_Gauss">[docs]</a>
<span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">integ_Gauss</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Integrate a univariate Gaussian distribution over a given interval.</span>

<span class="sd">    :param x_lb: Lower bound of the interval.</span>
<span class="sd">    :param x_ub: Upper bound of the interval.</span>
<span class="sd">    :param x: Mean of the Gaussian distribution.</span>
<span class="sd">    :param cov: Covariance of the Gaussian distribution.</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-4</span>  <span class="c1"># Add tiny epsilon to avoid NaN problems if the Gaussian is a Dirac (i.e., cov=0) and x_lb or x_ub equals x</span>
    <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x_ub</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="o">-</span> <span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span></div>



<span class="c1"># vmap to compute multivariate Gaussian integral in n dimensions</span>
<span class="n">vmap_integ_Gauss</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">integ_Gauss</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">vmap_integ_Gauss_per_dim</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">integ_Gauss</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">vmap_integ_Gauss_per_dim_single</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">integ_Gauss</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>


<div class="viewcode-block" id="minmax_Gauss">
<a class="viewcode-back" href="../../core.html#core.Gaussian_probabilities.minmax_Gauss">[docs]</a>
<span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">minmax_Gauss</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">wrap_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the min/max integral of a multivariate Gaussian distribution over a given interval, where the mean of the Gaussian lies in [mean_lb, mean_ub].</span>

<span class="sd">    :param x_lb: Lower bound of the interval.</span>
<span class="sd">    :param x_ub: Upper bound of the interval.</span>
<span class="sd">    :param mean_lb: Lower bound of the mean of the Gaussian distribution.</span>
<span class="sd">    :param mean_ub: Upper bound of the mean of the Gaussian distribution.</span>
<span class="sd">    :param cov: Covariance of the Gaussian distribution.</span>
<span class="sd">    :param wrap_array: Wrap at the indices where this array is True.</span>
<span class="sd">    :return: Min/max probabilities.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Determine point closest to mean of region over which to integrate</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_lb</span> <span class="o">+</span> <span class="n">x_ub</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">closest_to_mean</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">mean_ub</span><span class="p">,</span> <span class="n">mean</span><span class="p">),</span> <span class="n">mean_lb</span><span class="p">)</span>

    <span class="c1"># Maximum probability is the product</span>
    <span class="n">p_max</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">vmap_integ_Gauss</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">closest_to_mean</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span> <span class="o">*</span> <span class="o">~</span><span class="n">wrap_array</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">wrap_array</span><span class="p">)</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">vmap_integ_Gauss</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span> <span class="o">*</span> <span class="o">~</span><span class="n">wrap_array</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">wrap_array</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">vmap_integ_Gauss</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span> <span class="o">*</span> <span class="o">~</span><span class="n">wrap_array</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">wrap_array</span>
    <span class="n">p_min</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p_min</span><span class="p">,</span> <span class="n">p_max</span><span class="p">])</span></div>



<div class="viewcode-block" id="minmax_Gauss_per_dim">
<a class="viewcode-back" href="../../core.html#core.Gaussian_probabilities.minmax_Gauss_per_dim">[docs]</a>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">minmax_Gauss_per_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">wrap</span><span class="p">,</span> <span class="n">x_lb_per_dim</span><span class="p">,</span> <span class="n">x_ub_per_dim</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">state_space_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the min/max integral of a multivariate Gaussian distribution over a given interval, where the mean of the Gaussian lies in [mean_lb, mean_ub].</span>
<span class="sd">    Exploit rectangular partition to compute much fewer Gaussian integrals</span>

<span class="sd">    :param n: Dimension of the state space.</span>
<span class="sd">    :param wrap: Wrap at the indices where this array is True.</span>
<span class="sd">    :param x_lb_per_dim: Lower bound of the interval per dimension.</span>
<span class="sd">    :param x_ub_per_dim: Upper bound of the interval per dimension.</span>
<span class="sd">    :param mean_lb: Lower bound of the mean of the Gaussian distribution.</span>
<span class="sd">    :param mean_ub: Upper bound of the mean of the Gaussian distribution.</span>
<span class="sd">    :param cov: Covariance of the Gaussian distribution.</span>
<span class="sd">    :param state_space_size: Size of the state space per dimension (i.e., size of the &quot;state space box&quot;)</span>
<span class="sd">    :return:</span>
<span class="sd">        - Min/max probabilities.</span>
<span class="sd">        - Lower bound probabilities.</span>
<span class="sd">        - Upper bound probabilities.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">probs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">prob_low</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">prob_high</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">p_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_min</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># TODO: Make this more rigorous</span>
            <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="n">state_space_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state_space_size</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="n">x_lb</span> <span class="o">=</span> <span class="n">x_lb_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span>
                <span class="n">x_ub</span> <span class="o">=</span> <span class="n">x_ub_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span>

                <span class="c1"># Determine point closest to mean of region over which to integrate</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_lb</span> <span class="o">+</span> <span class="n">x_ub</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">closest_to_mean</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">mean_ub</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mean</span><span class="p">),</span> <span class="n">mean_lb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Maximum probability is the product</span>
                <span class="n">p_max</span> <span class="o">+=</span> <span class="n">vmap_integ_Gauss_per_dim</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">closest_to_mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

                <span class="n">p1</span> <span class="o">=</span> <span class="n">vmap_integ_Gauss_per_dim_single</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">vmap_integ_Gauss_per_dim_single</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">p_min</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_lb</span> <span class="o">=</span> <span class="n">x_lb_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">x_ub</span> <span class="o">=</span> <span class="n">x_ub_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Determine point closest to mean of region over which to integrate</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_lb</span> <span class="o">+</span> <span class="n">x_ub</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">closest_to_mean</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">mean_ub</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mean</span><span class="p">),</span> <span class="n">mean_lb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Maximum probability is the product</span>
            <span class="n">p_max</span> <span class="o">=</span> <span class="n">vmap_integ_Gauss_per_dim</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">closest_to_mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

            <span class="n">p1</span> <span class="o">=</span> <span class="n">vmap_integ_Gauss_per_dim_single</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">vmap_integ_Gauss_per_dim_single</span><span class="p">(</span><span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">p_min</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>

        <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">p_min</span><span class="p">,</span> <span class="n">p_max</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">prob_low</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_min</span>
        <span class="n">prob_high</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_max</span>

    <span class="k">return</span> <span class="n">probs</span><span class="p">,</span> <span class="n">prob_low</span><span class="p">,</span> <span class="n">prob_high</span></div>



<div class="viewcode-block" id="interval_distribution_per_dim">
<a class="viewcode-back" href="../../core.html#core.Gaussian_probabilities.interval_distribution_per_dim">[docs]</a>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">interval_distribution_per_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">max_slice</span><span class="p">,</span> <span class="n">wrap</span><span class="p">,</span> <span class="n">wrap_array</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">number_per_dim</span><span class="p">,</span> <span class="n">per_dim_lb</span><span class="p">,</span> <span class="n">per_dim_ub</span><span class="p">,</span> <span class="n">i_lb</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">state_space_lb</span><span class="p">,</span> <span class="n">state_space_ub</span><span class="p">,</span>
                                  <span class="n">region_idx_array</span><span class="p">,</span> <span class="n">unsafe_states</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    For a given state-action pair, compute the probability intervals over all successor states.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Extract slices from the partition elements per dimension</span>
    <span class="n">x_lb</span> <span class="o">=</span> <span class="p">[</span><span class="n">dynslice</span><span class="p">(</span><span class="n">per_dim_lb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i_lb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_slice</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">x_ub</span> <span class="o">=</span> <span class="p">[</span><span class="n">dynslice</span><span class="p">(</span><span class="n">per_dim_ub</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i_lb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_slice</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># List of indexes of the partition elements in the slices above</span>
    <span class="n">prob_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_slice</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">i_lb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># Compute the probability intervals for each dimension</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">prob_low</span><span class="p">,</span> <span class="n">prob_high</span> <span class="o">=</span> <span class="n">minmax_Gauss_per_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">wrap</span><span class="p">,</span> <span class="n">x_lb</span><span class="p">,</span> <span class="n">x_ub</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">state_space_ub</span> <span class="o">-</span> <span class="n">state_space_lb</span><span class="p">)</span>

    <span class="n">prob_low_prod</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">,</span> <span class="n">prob_low</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">decimals</span><span class="p">)</span>
    <span class="n">prob_high_prod</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">,</span> <span class="n">prob_high</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">decimals</span><span class="p">)</span>

    <span class="c1"># Note: meshgrid is used to get the Cartesian product between the indexes of the partition elements in every state space dimension, but meshgrid sorts in the wrong order.</span>
    <span class="c1"># To fix this, we first flip the order of the dimensions, then compute the meshgrid, and again flip the columns of the result. This ensures the sorting is in the correct order.</span>
    <span class="n">prob_idx_flip</span> <span class="o">=</span> <span class="p">[</span><span class="n">prob_idx</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">prob_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">prob_idx_flip</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">prob_idx_clip</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">prob_idx</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">number_per_dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">prob_id</span> <span class="o">=</span> <span class="n">region_idx_array</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">prob_idx_clip</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span>

    <span class="n">p_lowest</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="n">decimals</span>

    <span class="c1"># Only keep nonzero probabilities, and also filter spurious indices that were added to keep arrays in JAX of fixed size</span>
    <span class="n">prob_nonzero</span> <span class="o">=</span> <span class="p">(</span><span class="n">prob_high_prod</span> <span class="o">&gt;</span> <span class="n">p_lowest</span><span class="p">)</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">prob_idx</span> <span class="o">&lt;</span> <span class="n">number_per_dim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># For the nonzero probabilities, also set a (very small) minimum lower bound probability (to ensure the IMDP is &quot;graph-preserving&quot;)</span>
    <span class="n">prob_low_prod</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">p_lowest</span> <span class="o">*</span> <span class="n">prob_nonzero</span><span class="p">,</span> <span class="n">prob_low_prod</span><span class="p">)</span>
    <span class="n">prob_high_prod</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">p_lowest</span> <span class="o">*</span> <span class="n">prob_nonzero</span><span class="p">,</span> <span class="n">prob_high_prod</span><span class="p">)</span>

    <span class="c1"># Stack lower and upper bounds such that such prob[s] is an array of length two representing a single interval</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">prob_low_prod</span><span class="p">,</span> <span class="n">prob_high_prod</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Compute probability to end outside of partition</span>
    <span class="n">prob_state_space</span> <span class="o">=</span> <span class="n">minmax_Gauss</span><span class="p">(</span><span class="n">state_space_lb</span><span class="p">,</span> <span class="n">state_space_ub</span><span class="p">,</span> <span class="n">mean_lb</span><span class="p">,</span> <span class="n">mean_ub</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">wrap_array</span><span class="p">)</span>
    <span class="n">prob_absorbing</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prob_state_space</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">decimals</span><span class="p">)</span>
    <span class="n">prob_absorbing</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">p_lowest</span> <span class="o">*</span> <span class="p">(</span><span class="n">prob_absorbing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">prob_absorbing</span><span class="p">)</span>

    <span class="c1"># Keep this distribution only if the probability of reaching the absorbing state is less than given threshold</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">unsafe_states_slice</span> <span class="o">=</span> <span class="n">unsafe_states</span><span class="p">[</span><span class="n">prob_id</span><span class="p">]</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="p">(((</span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prob</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="o">~</span><span class="n">unsafe_states_slice</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">prob_absorbing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prob</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">unsafe_states_slice</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">prob</span><span class="p">,</span> <span class="n">prob_idx</span><span class="p">,</span> <span class="n">prob_id</span><span class="p">,</span> <span class="n">prob_nonzero</span><span class="p">,</span> <span class="n">prob_absorbing</span><span class="p">,</span> <span class="n">keep</span></div>



<div class="viewcode-block" id="compute_probability_intervals">
<a class="viewcode-back" href="../../core.html#core.Gaussian_probabilities.compute_probability_intervals">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_probability_intervals</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">frs</span><span class="p">,</span> <span class="n">max_slice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute probability intervals for all states and actions of the IMDP.</span>

<span class="sd">    :param args: Argument object.</span>
<span class="sd">    :param model: Model object.</span>
<span class="sd">    :param partition: Partition object.</span>
<span class="sd">    :param frs: Forward reachable sets.</span>
<span class="sd">    :param max_slice: Array where each element is the maximum number of partition elements to consider in each dimension.</span>
<span class="sd">    :return:</span>
<span class="sd">        - prob: Probability intervals per state-action pair</span>
<span class="sd">        - prob_id: Successor states associated with these probability intervals per state-action pair</span>
<span class="sd">        - prob_absorbing: Probability interval of reaching the absorbing state per state-action pair</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">prob_id</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">prob_nonzero</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">prob_absorbing</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># vmap to compute distributions for all actions in a state</span>
    <span class="n">vmap_interval_distribution_per_dim</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span>
        <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">interval_distribution_per_dim</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
        <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

    <span class="c1"># For all states</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">frs_s</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">frs</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">frs</span><span class="p">)):</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">p_idx</span><span class="p">,</span> <span class="n">p_id</span><span class="p">,</span> <span class="n">p_nonzero</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">vmap_interval_distribution_per_dim</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                                                                              <span class="n">max_slice</span><span class="p">,</span>
                                                                              <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">wrap</span><span class="p">)),</span>
                                                                              <span class="n">model</span><span class="o">.</span><span class="n">wrap</span><span class="p">,</span>
                                                                              <span class="n">args</span><span class="o">.</span><span class="n">decimals</span><span class="p">,</span>
                                                                              <span class="n">partition</span><span class="o">.</span><span class="n">number_per_dim</span><span class="p">,</span>
                                                                              <span class="n">partition</span><span class="o">.</span><span class="n">regions_per_dim</span><span class="p">[</span><span class="s1">&#39;lower_bounds&#39;</span><span class="p">],</span>
                                                                              <span class="n">partition</span><span class="o">.</span><span class="n">regions_per_dim</span><span class="p">[</span><span class="s1">&#39;upper_bounds&#39;</span><span class="p">],</span>
                                                                              <span class="n">frs_s</span><span class="p">[</span><span class="s1">&#39;idx_lb&#39;</span><span class="p">],</span>
                                                                              <span class="n">frs_s</span><span class="p">[</span><span class="s1">&#39;lb&#39;</span><span class="p">],</span>
                                                                              <span class="n">frs_s</span><span class="p">[</span><span class="s1">&#39;ub&#39;</span><span class="p">],</span>
                                                                              <span class="n">model</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s1">&#39;cov&#39;</span><span class="p">],</span>
                                                                              <span class="n">partition</span><span class="o">.</span><span class="n">boundary_lb</span><span class="p">,</span>
                                                                              <span class="n">partition</span><span class="o">.</span><span class="n">boundary_ub</span><span class="p">,</span>
                                                                              <span class="n">partition</span><span class="o">.</span><span class="n">region_idx_array</span><span class="p">,</span>
                                                                              <span class="n">partition</span><span class="o">.</span><span class="n">critical</span><span class="p">[</span><span class="s1">&#39;bools&#39;</span><span class="p">])</span>

        <span class="n">keep</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">prob</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">prob_id</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_id</span><span class="p">)</span>
        <span class="n">prob_nonzero</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_nonzero</span><span class="p">)</span>
        <span class="n">prob_absorbing</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pa</span><span class="p">),</span> <span class="n">args</span><span class="o">.</span><span class="n">decimals</span><span class="p">)</span>

        <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NaN probabilities in state </span><span class="si">{}</span><span class="s1"> at position </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nans</span><span class="p">)))</span>

    <span class="n">pAbs_min</span> <span class="o">=</span> <span class="mf">0.001</span>

    <span class="n">prob</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">prob_nonzero</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]],</span> <span class="n">args</span><span class="o">.</span><span class="n">decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">keep</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">prob</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">prob_absorbing</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pAbs_min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">decimals</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">keep</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">prob_absorbing</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">prob_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="n">prob_nonzero</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">keep</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]}</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">prob_id</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-- Number of times function was compiled:&#39;</span><span class="p">,</span> <span class="n">interval_distribution_per_dim</span><span class="o">.</span><span class="n">_cache_size</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">prob</span><span class="p">,</span> <span class="n">prob_id</span><span class="p">,</span> <span class="n">prob_absorbing</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Thom Badings.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>